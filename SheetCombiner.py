import subprocess
import pandas as pd

# Function to run the subprocesses for a given URL
def run_subprocesses(url):
    # Execute script 1 with the URL as an argument
    subprocess.run(["python", "CityDataScraper.py", url])

    # Execute script 2 with the URL as an argument
    subprocess.run(["python", "BuildingStatusScraper.py", url])

    # Execute script 3 with the URL as an argument
    subprocess.run(["python", "architectInfoGetter.py", url])

    # Execute script 4 with the URL as an argument
    subprocess.run(["python", "imageGetter.py", url])

    # Read the Excel file generated by CityDataScraper.py (skyscraper_data_modified.xlsx)
    df_script1 = pd.read_excel('skyscraper_data_modified.xlsx')

    # Read the Excel file generated by BuildingStatusScraper.py (status_values.xlsx)
    df_script2 = pd.read_excel('status_values.xlsx', header=None)

    # Read the Excel file generated by the architectInfoGetter.py script (extracted_text.xlsx)
    df_architects = pd.read_excel('extracted_text.xlsx')

    try:
        # Read the Excel file generated by the image getter script (image_urls.xlsx)
        df_images = pd.read_excel('image_urls.xlsx', header=None)

        # Merge the script 1 DataFrame with the architectInfoGetter.py DataFrame based on index
        df_combined = pd.concat([df_script1, df_architects], axis=1)

        # Rename the newly added column to 'Architect (from architectgetter)'
        df_combined = df_combined.rename(columns={'Architect': 'Architect'})

        # Get the number of populated cells in script 2 data
        num_cells = df_script2.count().values[0]

        # Extract the 'Status' column from script 2 data
        status_values = df_script2.iloc[:num_cells, 0]

        # Adjust the size of 'Status' values to match the number of rows in df_combined DataFrame
        status_values = list(status_values) + [None] * (len(df_combined) - len(status_values))

        # Add the 'Status' column to df_combined DataFrame
        df_combined['Status'] = status_values

        # Check if the first column exists in df_images DataFrame
        if 0 in df_images.columns:
            # Add the first column to df_combined DataFrame as 'Image' - Added
            df_combined['Image'] = df_images[0]
        else:
            raise KeyError("First column not found in df_images DataFrame.")
    except FileNotFoundError:
        print("Error: image_urls.xlsx file not found.")

    # Save the updated DataFrame to a new Excel file
    df_combined.to_excel('combined_data.xlsx', index=False)

    print("Data successfully combined and saved to combined_data.xlsx.")


# Function to combine the data from two Excel files
def combine_data(first_file, second_file):
    df_first = pd.read_excel(first_file)
    df_second = pd.read_excel(second_file)

    # Check if 'Building' column exists in both DataFrames
    if 'Building Name' in df_first.columns and 'Building Name' in df_second.columns:
        # Concatenate both tables
        df_combined = pd.concat([df_first, df_second], ignore_index=True)
        df_combined = df_combined.drop_duplicates(subset='Building Name')
    elif 'Building Name' in df_first.columns:
        df_combined = df_first
    elif 'Building Name' in df_second.columns:
        df_combined = df_second
    else:
        raise KeyError("Neither DataFrame has a 'Building Name' column.")

    return df_combined


# Function to combine the data from three Excel files
def combine_data_three_files(first_file, second_file, third_file):
    df_first = pd.read_excel(first_file)
    df_second = pd.read_excel(second_file)
    df_third = pd.read_excel(third_file)

    # Check if 'Building' column exists in all three DataFrames
    if 'Building Name' in df_first.columns and 'Building Name' in df_second.columns and 'Building Name' in df_third.columns:
        # Concatenate all three tables
        df_combined = pd.concat([df_first, df_second, df_third], ignore_index=True)
        df_combined = df_combined.drop_duplicates(subset='Building Name')
    else:
        raise KeyError("One or more DataFrames do not have a 'Building Name' column.")

    return df_combined


# Run the subprocesses for the first URL
url = input("Enter the first URL: ")
run_subprocesses(url)

# Read the Excel file generated by the first run (combined_data.xlsx)
df_combined = pd.read_excel('combined_data.xlsx')

# Save the first run's data to a new Excel file (combined_data_first.xlsx)
df_combined.to_excel('combined_data_first.xlsx', index=False)

# Flag to determine if the loop should continue
continue_flag = True

while continue_flag:
    # Prompt the user if they want to check another URL
    user_choice = input("Do you want to check another URL? (yes/no): ")
    if user_choice.lower() != 'yes':
        continue_flag = False
        break

    # Prompt the user for the new URL
    url = input("Enter the new URL: ")

    # Run the subprocesses for the new URL
    run_subprocesses(url)

    # Combine the new data with the existing data
    df_combined = combine_data('combined_data_first.xlsx', 'combined_data.xlsx')

    # Sort the data by height in descending order
    df_combined = df_combined.sort_values(by='Height', ascending=False)

    # Save the second run's data to a new Excel file (combined_data_second.xlsx)
    df_combined.to_excel('combined_data_second.xlsx', index=False)

# Prompt the user if they want to search for a third URL
user_choice = input("Do you want to search for a third URL? (yes/no): ")
if user_choice.lower() == 'yes':
    # Prompt the user for the third URL
    url = input("Enter the third URL: ")

    # Run the subprocesses for the third URL
    run_subprocesses(url)

    # Combine the new data with the existing data
    df_combined = combine_data_three_files('combined_data_first.xlsx', 'combined_data_second.xlsx', 'combined_data.xlsx')

    # Sort the data by height in descending order
    df_combined = df_combined.sort_values(by='Height', ascending=False)

    # Save the final run's data to a new Excel file (combined_data_final.xlsx)
    df_combined.to_excel('combined_data_final.xlsx', index=False)

print("Data successfully combined and saved.")
